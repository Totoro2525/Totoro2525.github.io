<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Service启动并传输数据]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%90%AF%E5%8A%A8Service%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[Service是四大组件之一，Service是服务的意思，像Windows上面的服务一样，服务是在后台运行的，承担着静悄悄，默默的在后台付出的工作。在开发过程中Service可以在很多地方使用，比如播放多媒体的时候用户启动了其他Activity ，这个时候程序要在后台继续播放；或者在后台记录用户地理位置的改变，或者启动服务来一直监听某种事件等。虽然Service存在的价值不如Activity,但是一般都让Service执行耗时时间较长的操作。下面我们详细介绍一下Service。 一，启动Service主要有两种方式: startService(),调用者与服务之间没有关联，即时调用者退出，服务仍然可以运行。 bindService(),调用者与服务绑定在一起，调用者一旦退出(启动Service的Activity退出，Service也退出)，服务也退出。 绑定服务是调用bindService方法启动的，绑定调用了onBind生命周期方法，改方法返回IBinder对象，同时启动服务的Activity必须提供ServiceConnect接口的实现类，它有两个方法onServiceConnected和onServiceDisconnected方法，监听Activity与服务类之间的连接。 二，Service的生命周期:1.Started Service的生命周期： onCreate()：创建服务 onStartCommand()：服务开始运行（在2.0以前版本中，使用onStart()回调方法） onDestroy() ：服务被停止【详细说明：】 在程序中调用：context.bindService()会触发执行Service生命周期中的onCreate()、onBind()回调方法，此时服务开始运行； onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。此后调用者（Context，例如Activity）会和Service绑定在一起； 如果调用Service的调用者Context退出了，那么会依次调用Service生命周期中的* onUnbind()、onDestroy()回调方法，会让服务停止； 所以BindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。 ##三，绑定Service通信：1.向Service内部传递数据：创建一个Activity,用来启动Service,我们在Activity里面创建一个布局，如下所示：EditText用来动态改变向Service里面数据，点击同步数据按钮用来将Activity里面的数据传递到Service里面。 将数据同步到Service里面需要利用服务得IBinder对象。下面是我的服务类：点击显/隐折叠代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyService extends Service &#123; private boolean running = false; private String data = "默认信息";//创建一个字符串，用来接收数据 public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return new Binder();//④返回Binder的事例 &#125; /** *②创建一个类继承Binder,来对data数据进行更新 */ public class Binder extends android.os.Binder&#123; public void setData(String data)&#123;//③写一个公共方法，用来对data数据赋值。 MyService.this.data = data; &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); running = true; new Thread()&#123; //①创建一个Thread用来数据传递进来的data数据。 @Override public void run() &#123; super.run(); while (running)&#123; System.out.println(data);//打印数据 try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); running = false; &#125; 在Activity中，需要实现ServiceConnection接口，并且在绑定成功的onServiceConnected方法中初始化Binder对象： 1.首先定义变量 private MyService.Binder binder = null; 2.在onServiceConnected方法中进行初始化：1234@Override public void onServiceConnected(ComponentName name, IBinder service) &#123; binder = (MyService.Binder) service; &#125; 3.点击同步数据按钮向Service里面赋值： binder.setData(editText.getText().toString()); 具体代码如下所示：点击显/隐折叠代码 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity implements OnClickListener, ServiceConnection &#123; private EditText editText; private MyService.Binder binder = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.content_main); editText = (EditText) findViewById(R.id.edit); findViewById(R.id.bindService).setOnClickListener(this); findViewById(R.id.unbindService).setOnClickListener(this); findViewById(R.id.btnSync).setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bindService://点击绑定服务按钮 bindService(new Intent(this,MyService.class),this, Context.BIND_AUTO_CREATE); break; case R.id.unbindService://解除绑定服务按钮 unbindService(this); break; case R.id.btnSync://同步数据按钮 if (binder != null)&#123; binder.setData(editText.getText().toString()); &#125; break; &#125; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; binder = (MyService.Binder) service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125;&#125; 这样就完成了想Service内部的数据传递。 四，service向Activity传递数据上面介绍了Activity向Service内部传值，现在我们来介绍一下Service向Activity传递数据： 从Service向Activity传值，我们需要利用接口，首先在MyService里面自定义一个接口CallBack,实现onDataChanged方法;123public static interface CallBack&#123; void onDataChanged(String data); &#125; 在MyService里面定义CallBack类型的变量，并且实现它的set方法，来获得CallBack的实例。在MyService的Oncrate方法中定义一个变量i,然后动态改变i的数值，然后通过callback.onDataChanged(“数据=”+i) 将数据进行传递。具体实现方法如下所示：点击显/隐折叠代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MyService extends Service &#123; private boolean running = false; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return new Binder(); &#125; /** *创建一个类继承Binder,来进行 */ public class Binder extends android.os.Binder&#123; public MyService getService()&#123; return MyService.this; &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); running = true; new Thread()&#123; @Override public void run() &#123; super.run(); int i = 0; while (running)&#123; i++; if (callback != null)&#123; callback.onDataChanged("数据="+i); &#125; try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); running = false; &#125; private CallBack callback = null; public void setCallback(CallBack callback) &#123; this.callback = callback; &#125; public static interface CallBack&#123; void onDataChanged(String data); &#125;&#125; 在Activity中我们需要1.获得Myservice的实例来调用serCallBack方法，所以我在MyService的Binder方法里面添加了获取MyService实例的方法。 2.将调用CallBack接口之后onDataChanged方法返回的值赋值到TextView上面，还是用到了servce的IBinder对象。具体实现方法如下所示：点击显/隐折叠代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends AppCompatActivity implements OnClickListener, ServiceConnection &#123; private TextView textView; private MyService.Binder binder = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.content_main); textView = (TextView) findViewById(R.id.tvout); findViewById(R.id.bindService).setOnClickListener(this); findViewById(R.id.unbindService).setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bindService://点击绑定服务按钮 bindService(new Intent(this,MyService.class),this, Context.BIND_AUTO_CREATE); break; case R.id.unbindService://解除绑定服务按钮 unbindService(this); break; &#125; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; binder = (MyService.Binder) service; binder.getService().setCallback(new MyService.CallBack() &#123; @Override public void onDataChanged(String data) &#123;//因为在Service里面赋值data是在Thread中进行的，所以我们不能直接在这里将返回的值展示在TextView上。 Message msg = new Message(); Bundle bundle = new Bundle(); bundle.putString("data",data); msg.setData(bundle); handler.sendMessage(msg); &#125; &#125;); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); textView.setText(msg.getData().getString("data")); &#125; &#125;;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比悲伤更悲伤的故事：我不能在你身边]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%9C%89%E4%B8%80%E7%A7%8D%E6%82%B2%E4%BC%A4%2F</url>
    <content type="text"><![CDATA[有一种悲伤 打 开 的 第 一 件 事 情 就 是 想起我 竭 尽 全 力 不 负 遇 见 ▼ 我的不定时更新｜ 与你说晚安 “人为什么要结婚啊？” “大概是当你老的时候，或是需要被照顾的时候，那个人可以理直气壮地一直陪在你身边。” 今晚上跟陈小朋友去电影院看了《比悲伤更悲伤的故事》，去之前就听说这部电影很催泪，以为自己不会再那么容易被俗套剧情打动，没想到看到最后，还是红了眼眶。 K和Cream从高中起相识，一个是父亲去世，被母亲抛弃；一个是双亲在车祸中去世，相似的经历，同样的孤独，让他们自然而然地走到了一起，同居十几年。 其实就算故事的剧情里没有铺垫，十几年的时间是谁都无法忽略不计的，那是各自人生阶段里最好也是最糟糕的青春。 更何况是这样身世彼此陪伴的两个人，他们早已经是对方世界里的不可或缺。 K知道自己身患绝症，时间不多，他最担心的是Cream。 希望用给她找一个好男人的方式，帮她安顿好他去世后的生活，可是他不知道的是，当Cream知道他身患绝症以后，她没有拆穿，也没有说破，只是默默的成全他的所有，包括希望自己去找个好男人嫁了。 不太记得是从哪一段开始哭的，但看到K从婚纱店跑出来，在天桥上，他以为对面站着的是穿着婚纱的Cream，结果不过是自己的一场幻觉而已，电影院里所有人也都在默默的擦眼泪。 他们都竭尽全力，把自己所能想到的最好的爱，给了对方。 比悲伤更悲伤的是，两个人明明相互惦念着，相互深爱着，却没有好好地在一起过。 看到K明明已经把“我爱你”三个字打进了对话框，最后还是一个字一个字的删掉了，换成了一句“你要幸福”发出去。Cream眼睛里含着泪水，回了一句“谢谢”。 其实，只要他勇敢地说出那句话，宋媛媛一定会义无反顾地和他在一起，无论他贫穷或富有，无论他健康或疾病，陪在他的身边，直到生命的最后一刻。 就像Cream所说的，我要的不是在寒冬中送我热咖啡的人，而是下雨天陪我一起吃冰的人。 我要的不是守护我的人，而是和我一起冒险的人，我要的不是别人，而是你。 K没有说出口，Cream也满足他的心愿，和别人走进了婚姻殿堂，看过电影的人都知道，其实Cream之前就发现K患病的事，也知道了他一直自己默默承受，还有为她所做的一切。 可是爱情这件事，是骗不了人的。Cream骗不了自己的心，她还是选择回到了K的身边。在K最孤独最需要拥抱的时候，给了他最深的拥抱，陪他走完生命的最后时光。 我想，如果在生命的最后一刻，没有看到最爱的人，那才是最遗憾的。 相比较电影里那些排除万难都为对方着想的爱情，再看看身边那些近在咫尺却无比计较，生怕自己多付出一分一毫的感情，等到失去的时候，除了遗憾和回忆，也再没什么其他了吧。 电影的结束，是爱情的再次相遇。现实里更多的，很多人都在爱情里错过或者迷惘。 我们总以为下次还有机会，直到有一天，离别摆在了眼前，才知道没有什么来日方长，想做的事情就马上做，想见的人就马上见，喜欢的人就好好珍惜，不要等到来不及，不要让自己有遗憾。 也许正是因为知道了限期，他们才会竭尽全力把自己最好的爱给对方。就像张敬轩那首《只是太爱你》唱的：“因为不知道下一辈子还是否能遇见你，所以我今生才会那么努力，把最好的给你。” 我们的人生只有一次，无法重来，重要的不是把人生过得多精彩，而是如何让人生的遗憾少一点，再少一点。 那什么才是人生的遗憾呢？人生的遗憾不是做错了什么，而是我本可以，但我却没这么做。 《比悲伤更悲伤的故事》里有一段说： 我不喜欢永远，因为少了一个人永远就不成立了，下辈子听起来还不错，像一个浪漫的约定。 下辈子的话，做个戒指、做个眼镜、做床棉被都好，只要能一直陪在你身旁就好。 慢慢的男女都会明白，无法跟喜欢的人在一起是人生的常态。 慢慢的大家都会明白爱不爱，可不可以在一起，能不能结婚是三件截然不同的事。 慢慢的我们都会体会到比悲伤更悲伤的事，不是他不爱你，而是明明两个人互相惦念、互相喜欢，却无法在这一辈子在一起，只能希望寄托在下辈子身上了。 所以我想，在那些在电影院里哭成泪人的女孩身上，应该都曾发生过一些爱而不得、无可奈何的故事吧！ 只是借着电影的由头，好好哭一场 1、如果爱必须要说出口，那哑巴如何相爱。 故事来源：\@雪泥鸿爪 第一年，我高一，他高二。 我在楼梯的拐角差点撞到他，他戴着白色耳机，不知道有没有听到我心慌意乱的对不起。 后来的周一升旗仪式上，他做国旗下讲话，讲完认认真真的鞠躬致谢。距离他几十米的我，心里涟漪再起。 第二年，我高二，他高三。 我们换了班主任，竟然是他的母亲。 最后一节课，我胃疼去办公室请假，正遇上他。班主任说，那你扶她去校门口吧。 我一直记着那几百米的距离，初春的天气，他扶着我的胳膊，蓝色的校服相互依偎。 第三年，我高三，他大一。 学校里没有他，连那偶尔的擦肩而过也没有了，我也不再在校园里四处游荡。 第四年，我大一，他大二。 我终于再一次和他站在同一片土地，他依旧优秀，在大学里风生水起。 那年冬天的第一场雪，下得很大，我踩着厚厚的积雪去图书馆还书。 在图书馆门口，我就这样看到了他。他还是高中的样子，站在那里，笔直挺拔。 他笑着接过一个女孩子手里的书，给她的一只手带上手套，另一只手放进他的大衣口袋里握住。 那天晚上，我把这几年写的日记本全都放进了一个小纸箱里。 喜欢了一个人五年，最终还是成了人海茫茫中的两个陌生人。 2、 说真话需要勇气，但为了爱的人， 将谎话说到底，需要更大的勇气。 故事来源：\@喵小七 我闺蜜很漂亮，公认的班花。 班里一个男生喜欢她，但是又不敢正面打交道，然后就让我帮他送情书、写信、送礼物、传悄悄话。 然后我帮他追我闺蜜追了三年，直到初中毕业都没成。 闺蜜当时也不是不喜欢那男生啊，只是太懵懂，觉得做朋友就好了。 七年以后我跟闺蜜聚在一起，提起当初的事情。我半开玩笑说，“哎，你干嘛不答应人家，人家真的挺好的，你不要给我多好。” 闺蜜：“你喜欢他？”，我：“嗯”。 闺蜜：“那你干嘛不说？” 我说：“可是我知道他一心喜欢你呀，他跟你在一起我才会觉得幸福。” 后来大概闺蜜偷偷跟那个男生讲了，那个男生特意要到我的联系方式，然后说了声：“谢谢你”。 3、 “如果还有来生，你想做什么。？” “除了做人，什么都行。戒指，眼镜，床，日记。” “下辈子做这些东西？有什么意思？” “你可以把我买回去，在你身边永远都有意思。” 故事来源：\@小机灵 临别之际，我大包小包的在食堂门口等他。 还记得他穿着的是牛仔裤，配白色T恤，他看着我说：“有什么事？” 我笑着说：“没什么事，就觉得马上要放假了，两个月见不着特意跟你告个别。” 他也笑了：“还特意告个别。” 我突然不知道哪里来的勇气，说了一句：“能抱下你吗？” 他犹豫地看着我：“抱……抱吧？” 我轻轻抱了一下，小心翼翼，生怕我们的感情就像瓷器，稍微用力，就出现裂缝。 那次，我还送了他一个红豆骰子链子，以表相思之情。 虽然，不知道他现在怎么处理了那个红豆链子，我是真的挺想成为那个红豆链子，哪怕只是待在他身边一小段时间。 电影的最后一幕，看见K和Cream的墓碑，我突然明白了：这就是之前铺垫的下辈子。 因为我不知道下一辈，还是否能遇见你，所以我今生才会和你一起离开。 但我们都知道，这世上根本没有下辈子。 所以一定要在这辈子去珍惜自己想爱的人，才不枉这一生。 谁叫这人生稍纵即逝。]]></content>
      <categories>
        <category>movie</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My secret]]></title>
    <url>%2F2019%2F03%2F25%2Fsecery%2F</url>
    <content type="text"><![CDATA[This is a my secret！！ I love LinWenFan~]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello WorldToday I created my blog…..date:2019.03.24 My information: Name: Chenyuxiang Age: 22 Sex：man School:Minnan Normal University]]></content>
  </entry>
</search>

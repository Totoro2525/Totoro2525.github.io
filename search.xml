<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ContentProvider]]></title>
    <url>%2F2019%2F04%2F03%2FContentProvider%2F</url>
    <content type="text"><![CDATA[android 四大基本组件 的ContentProvider（内容提供者） 这个组件其实就是一个应用进行数据或数据库提供、共享其他应用获取数据的组件，其大致的结构图如下：其中uri是一个重要的中间媒介。 联系到我们平时用的安卓程序，最常见的就是通讯录。在我们的安卓手机里，通讯录的设计其实是两个程序，其中有一个程序没有用户界面，单纯的存储着联系人信息，并且数据库结构复杂，这也是为了保证数据的安全。另外一个程序就是我们可以看见的通讯录程序。那么第一个程序就是一个ContentProvider，用于提供数据，而通讯录这个安卓手机内置软件，便是对ContentProvider所提供的程序进行增删改查。如果我们想要自己写一个ContentProvider，就要自定义类去继承ContentProvider，并实现其中的方法，我们自定义的这个ContentProvider用于给其他应用或程序提供数据。这个类的具体结构和其中的方法代码如下，各个方法的含义在注释中可见：点击显/隐折叠代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import android.content.ContentProvider;import android.content.ContentValues;import android.database.Cursor;import android.net.Uri;import android.support.annotation.Nullable;/** * Created by lzc on 16/6/22. */public class MyContentProvider extends ContentProvider &#123; @Override public boolean onCreate() &#123;//在创建ContentProvider时调用 return false; &#125; @Nullable @Override public Cursor query(Uri uri, String[] strings, String s, String[] strings1, String s1) &#123;//根据uri查询出selection制定的条件所匹配的全部纪录,并且可以指定查询那些列以什么方式(order)排序 return null; &#125; @Nullable @Override public String getType(Uri uri) &#123;//返回当前uri的MIME类型,如果该uri对应的数据可能包括多条记录 //那么MIME类型字符串就是vnd.android.dir/开头 //如果该URI对应的数据只有一条记录,该MIME类型字符串就是 以vnd.android.crusor.item/开头 return null; &#125; @Nullable @Override public Uri insert(Uri uri, ContentValues contentValues) &#123;//根据uri插入Values对应的纪录 return null; &#125; @Override public int delete(Uri uri, String s, String[] strings) &#123;//根据uri删除selection指定的条件所匹配的全部记录 return 0; &#125; @Override public int update(Uri uri, ContentValues contentValues, String s, String[] strings) &#123;//根据uri修改selection指定的条件所匹配的全部记录 return 0; &#125;&#125; 这个ContentProvider在实际应用中我们不常去自己定义，更多的时候我们只是使用系统，或其他应用的ContentProvider。 这里写一个简单的应用，功能是实现查看手机内的通讯录信息。点击显/隐折叠代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344import android.content.ContentResolver;import android.content.CursorLoader;import android.database.Cursor;import android.provider.ContactsContract;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ContentResolver cr = getContentResolver(); Cursor c = cr.query(ContactsContract.Contacts.CONTENT_URI,new String[]&#123;ContactsContract.Contacts._ID, ContactsContract.Contacts.DISPLAY_NAME&#125;,null,null,null); if(c!=null)&#123; while(c.moveToNext())&#123; int id = c.getInt(c.getColumnIndex("_ID")); System.out.println("id="+id); String name = c.getString(c.getColumnIndex("DISPLAY_NAME")); System.out.println("name:"+name); Cursor c1 = cr.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,new String[]&#123;ContactsContract.CommonDataKinds.Phone.NUMBER, ContactsContract.CommonDataKinds.Phone.TYPE&#125;, ContactsContract.CommonDataKinds.Phone.CONTACT_ID+"="+id,null,null); if(c1!=null)&#123; while (c1.moveToNext())&#123; int type = c1.getInt(c1.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE)); if(type == ContactsContract.CommonDataKinds.Phone.TYPE_HOME) Log.i("info","家庭电话:"+c1.getString(c1.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER))); else&#123; Log.i("info","手机:"+c1.getString(c1.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER))); &#125; &#125; &#125; c1.close(); &#125; &#125; c.close(); &#125;&#125; 注意：这里需要一个用户权限：1&lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt; 在写一个简单的应用功能为在手机通讯录中插入一条信息。 代码如下：点击显/隐折叠代码 12345678910111213141516171819202122232425262728293031323334import android.content.ContentResolver;import android.content.ContentUris;import android.content.ContentValues;import android.net.Uri;import android.provider.ContactsContract;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ContentResolver cr = getContentResolver(); //插入一行数据 ContentValues valuse = new ContentValues(); Uri uri = cr.insert(ContactsContract.RawContacts.CONTENT_URI,valuse); Long raw_contact_id = ContentUris.parseId(uri); valuse.clear(); //插入人名 valuse.put(ContactsContract.CommonDataKinds.StructuredName.RAW_CONTACT_ID,raw_contact_id); valuse.put(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME,"安卓入门进阶"); valuse.put(ContactsContract.CommonDataKinds.StructuredName.MIMETYPE, ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE); uri = cr.insert(ContactsContract.Data.CONTENT_URI,valuse); //插入电话信息 valuse.clear(); valuse.put(ContactsContract.CommonDataKinds.Phone.RAW_CONTACT_ID,raw_contact_id); valuse.put(ContactsContract.CommonDataKinds.Phone.NUMBER,"131111111111"); valuse.put(ContactsContract.CommonDataKinds.Phone.MIMETYPE, ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE); uri = cr.insert(ContactsContract.Data.CONTENT_URI,valuse); &#125;&#125; 注意：需要的用户权限为：12&lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt;&lt;uses-permission android:name="android.permission.WRITE_CONTACTS"/&gt; 一般系统提供的ContentProvider包括： －查询联系人 －增加联系人 －短信的读取 －通话记录 －多媒体 图片视频音频 至此，安卓开发的四大基本组件，大结局！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ContentProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BroadcastReceiver]]></title>
    <url>%2F2019%2F04%2F03%2FBroadcastReceiver%2F</url>
    <content type="text"><![CDATA[广播类似于activity和service，同样是android中的基本组件。作为开发者，只需要掌握广播接受者，不必去理解其底层的机制 1.Broadcast（广播）和BroadcastReceiver（广播接受者） 广播是一种广泛运用在应用程序之间传输信息的机制。而广播接受者是对发送出来的广播进行过滤接收并相应的一类组件，它用于接收来自系统和应用中的广播 用途：开机完成系统会发出一条广播网络状态发生改变时体统发出一条广播电池电量改变时，系统发出一条广播。2.广播接受者的生命周期 广播接受者的生命周期非常短，只有大概几秒钟，因此在BroadcastReceiver里不能做一些比较耗时的操作。如果用到了比较耗时的操作，应该通过发送给Intent给Service，由Service来完成。并且需要注意的是，不能使用子线程。 3.广播的种类 普通广播（Normal broadcasts）：所有监听该广播的广播接受者都可以接收和监听到该广播特点：（1）同级别接受先后是随机的（无序）。（2）级别低的后收到广播。（3）接收器不能阶段广播的继续传播也不能处理广播。（4）同级别动态注册高于静态注册。 有序广播（Ordered broadcasts）按照接受者的优先级顺序接收广播，优先级别在intent-filter中的priority中声明，－1000到1000之间，值越大，优先级越高。可以终止广播意图的继续传播。接受者可以篡改内容。特点：（1）同界别接受顺序是随机的。（2）能截断广播的继续传播，高级别的广播接收者收到该广播后，可以决定把该广播是否截断。（3）接受者能截断广播的继续传播，也能处理广播。（4）同级别动态注册高于静态注册。 异步广播（黏滞性滞留广播） 异步广播（黏滞性滞留广播） 4.普通广播优先级详解：（1）在布局中添加一个按钮，用于发送广播（2）点击发送广播按钮，携带数据发送广播，发送广播的按钮中执行如下代码：1234Intent intent = new Intent();intent.putExtra("msg","这是一条普通广播");intent.setAction("BC_ONE");sendBroadcast(intent); 其中BC_ONE用于过滤器过滤到该广播，该字符串可自定义。（3）新建一个类BroadcastReceiver1.java，继承BroadcastReceiver，实现方法onReceive()。（4）新建一个类BroadcastReceiver2.java，继承BroadcastReceiver，实现方法onReceive()。1234567891011121314import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;/** * Created by lzc on 16/6/21. */public class BroadcastReceiver1 extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String str = intent.getStringExtra("msg"); System.out.println("receiver1收到消息"+str); &#125;&#125; BroadcastReceiver2.java同理，只不过输出的是 receiver2收到消息 。（4）在AndroidManifest.xml中注册广播接受者。12345678910111213&lt;receiver android:name=".BroadcastReceiver1"&gt; &lt;intent-filter android:priority="100" &gt; &lt;action android:name="BC_ONE"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=".BroadcastReceiver2"&gt; &lt;intent-filter android:priority="200"&gt; &lt;action android:name="BC_ONE"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 如果filter里面不加priority属性的话，两个广播接受器应当同时接收到广播。也就是同级别接收顺序为无序。而加上priority属性，则是自定义接受器的级别，数字越大，级别越高，越先收到广播。另外，在AndroidManifest.xml中注册广播接受器属于静态注册，范围为全局。（5）运行以上代码，得到的结果是：06-21 13:56:01.452 10108-10108/com.example.lzc.broadcast I/System.out: receiver2收到消息这是一条普通广播06-21 13:56:01.462 10108-10108/com.example.lzc.broadcast I/System.out: receiver1收到消息这是一条普通广播由结果可见，receiver2比receiver1先接收到广播。这就是普通广播的优先级体现另外，如果在receiver2中添加截断广播的方法。abortBroadcast(),并不会截断广播。因为普通广播不允许被截断。（6）上面介绍了静态注册接收器，这里简单提一下动态注册，所谓动态注册，也就是在java代码中注册，有效范围是当前运行的程序。123IntentFilter intentfilter = new IntentFilter("BC_ONE");//该字符串为ActionBroadcastReceiver1 bc1 = new BroadcastReceiver1();registerReceiver(bc1,intentfilter); 5.有序广播优先级与特点： 发送有序广播的方法是sendOrderedBrocast() 其他操作和优先级与普通广播类似，但是我们会发现，有序广播既可以截断广播，也可以处理广播的数据，即在BroadcastReceiver2里面可以处理BroadcastReceiver1所发送的数据。（普通广播不可以处理） 6.异步广播（黏滞性滞留广播）简介（1）与其他两种广播形式不同的是，异步广播可以先发送广播在注册接收器。（2）发送方法是：sendStickyBroadcast（intent）（3）使用异步广播时需要一个用户权限1&lt;uses-permission android:name="android.permission.BROADCAST_STICKY"/&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BroadcastReceiver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service启动并传输数据]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%90%AF%E5%8A%A8Service%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[Service是四大组件之一，Service是服务的意思，像Windows上面的服务一样，服务是在后台运行的，承担着静悄悄，默默的在后台付出的工作。在开发过程中Service可以在很多地方使用，比如播放多媒体的时候用户启动了其他Activity ，这个时候程序要在后台继续播放；或者在后台记录用户地理位置的改变，或者启动服务来一直监听某种事件等。虽然Service存在的价值不如Activity,但是一般都让Service执行耗时时间较长的操作。下面我们详细介绍一下Service。 一，启动Service主要有两种方式: startService(),调用者与服务之间没有关联，即时调用者退出，服务仍然可以运行。 bindService(),调用者与服务绑定在一起，调用者一旦退出(启动Service的Activity退出，Service也退出)，服务也退出。 绑定服务是调用bindService方法启动的，绑定调用了onBind生命周期方法，改方法返回IBinder对象，同时启动服务的Activity必须提供ServiceConnect接口的实现类，它有两个方法onServiceConnected和onServiceDisconnected方法，监听Activity与服务类之间的连接。 二，Service的生命周期:1.Started Service的生命周期： onCreate()：创建服务 onStartCommand()：服务开始运行（在2.0以前版本中，使用onStart()回调方法） onDestroy() ：服务被停止【详细说明：】 在程序中调用：context.bindService()会触发执行Service生命周期中的onCreate()、onBind()回调方法，此时服务开始运行； onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。此后调用者（Context，例如Activity）会和Service绑定在一起； 如果调用Service的调用者Context退出了，那么会依次调用Service生命周期中的* onUnbind()、onDestroy()回调方法，会让服务停止； 所以BindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。 ##三，绑定Service通信：1.向Service内部传递数据：创建一个Activity,用来启动Service,我们在Activity里面创建一个布局，如下所示：EditText用来动态改变向Service里面数据，点击同步数据按钮用来将Activity里面的数据传递到Service里面。 将数据同步到Service里面需要利用服务得IBinder对象。下面是我的服务类：点击显/隐折叠代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyService extends Service &#123; private boolean running = false; private String data = "默认信息";//创建一个字符串，用来接收数据 public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return new Binder();//④返回Binder的事例 &#125; /** *②创建一个类继承Binder,来对data数据进行更新 */ public class Binder extends android.os.Binder&#123; public void setData(String data)&#123;//③写一个公共方法，用来对data数据赋值。 MyService.this.data = data; &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); running = true; new Thread()&#123; //①创建一个Thread用来数据传递进来的data数据。 @Override public void run() &#123; super.run(); while (running)&#123; System.out.println(data);//打印数据 try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); running = false; &#125; 在Activity中，需要实现ServiceConnection接口，并且在绑定成功的onServiceConnected方法中初始化Binder对象： 1.首先定义变量 private MyService.Binder binder = null; 2.在onServiceConnected方法中进行初始化：1234@Override public void onServiceConnected(ComponentName name, IBinder service) &#123; binder = (MyService.Binder) service; &#125; 3.点击同步数据按钮向Service里面赋值： binder.setData(editText.getText().toString()); 具体代码如下所示：点击显/隐折叠代码 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity implements OnClickListener, ServiceConnection &#123; private EditText editText; private MyService.Binder binder = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.content_main); editText = (EditText) findViewById(R.id.edit); findViewById(R.id.bindService).setOnClickListener(this); findViewById(R.id.unbindService).setOnClickListener(this); findViewById(R.id.btnSync).setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bindService://点击绑定服务按钮 bindService(new Intent(this,MyService.class),this, Context.BIND_AUTO_CREATE); break; case R.id.unbindService://解除绑定服务按钮 unbindService(this); break; case R.id.btnSync://同步数据按钮 if (binder != null)&#123; binder.setData(editText.getText().toString()); &#125; break; &#125; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; binder = (MyService.Binder) service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125;&#125; 这样就完成了想Service内部的数据传递。 四，service向Activity传递数据上面介绍了Activity向Service内部传值，现在我们来介绍一下Service向Activity传递数据： 从Service向Activity传值，我们需要利用接口，首先在MyService里面自定义一个接口CallBack,实现onDataChanged方法;123public static interface CallBack&#123; void onDataChanged(String data); &#125; 在MyService里面定义CallBack类型的变量，并且实现它的set方法，来获得CallBack的实例。在MyService的Oncrate方法中定义一个变量i,然后动态改变i的数值，然后通过callback.onDataChanged(“数据=”+i) 将数据进行传递。具体实现方法如下所示：点击显/隐折叠代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MyService extends Service &#123; private boolean running = false; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return new Binder(); &#125; /** *创建一个类继承Binder,来进行 */ public class Binder extends android.os.Binder&#123; public MyService getService()&#123; return MyService.this; &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); running = true; new Thread()&#123; @Override public void run() &#123; super.run(); int i = 0; while (running)&#123; i++; if (callback != null)&#123; callback.onDataChanged("数据="+i); &#125; try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); running = false; &#125; private CallBack callback = null; public void setCallback(CallBack callback) &#123; this.callback = callback; &#125; public static interface CallBack&#123; void onDataChanged(String data); &#125;&#125; 在Activity中我们需要1.获得Myservice的实例来调用serCallBack方法，所以我在MyService的Binder方法里面添加了获取MyService实例的方法。 2.将调用CallBack接口之后onDataChanged方法返回的值赋值到TextView上面，还是用到了servce的IBinder对象。具体实现方法如下所示：点击显/隐折叠代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends AppCompatActivity implements OnClickListener, ServiceConnection &#123; private TextView textView; private MyService.Binder binder = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.content_main); textView = (TextView) findViewById(R.id.tvout); findViewById(R.id.bindService).setOnClickListener(this); findViewById(R.id.unbindService).setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bindService://点击绑定服务按钮 bindService(new Intent(this,MyService.class),this, Context.BIND_AUTO_CREATE); break; case R.id.unbindService://解除绑定服务按钮 unbindService(this); break; &#125; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; binder = (MyService.Binder) service; binder.getService().setCallback(new MyService.CallBack() &#123; @Override public void onDataChanged(String data) &#123;//因为在Service里面赋值data是在Thread中进行的，所以我们不能直接在这里将返回的值展示在TextView上。 Message msg = new Message(); Bundle bundle = new Bundle(); bundle.putString("data",data); msg.setData(bundle); handler.sendMessage(msg); &#125; &#125;); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); textView.setText(msg.getData().getString("data")); &#125; &#125;;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[activity－activity之间的数据传递]]></title>
    <url>%2F2019%2F03%2F29%2Factivity%EF%BC%8Dactivity%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[我们已经基本了解了android中的activity的概念、跳转、及几种启动模式，然而，在实际应用中并不会单纯的启动或跳转activity，通常是在启动一个新的activity时总要携带着各式各样的数据或数据包。1.传递简单的数据类型 从activity Aaty跳转到Baty并携带基本的数据类型 Aaty： 123Intent i ＝ new Intent(Aaty.this,Baty.class); //初始化数据i.putExtra(“data”,”test”);startActivity(i); Baty： 12Intent i = getIntent(); //获取数据i.getStringExtra(“data”); 利用Intent对象作为数据的载体。 2.传递数据包 从activity Aaty跳转到Baty并携带数据包（Bundle） Aaty： 123456Intent i ＝ new Intent(Aaty.this,Baty.class);Bundle b = new Bundle(); //初始化bundleb.putString(“stringdata”,”datatest”);b.putInt(“intdata”,12);i.putExtras(b);startActivity(i); Baty： 1234Intent i = getIntent(); //获取bundleBundle data = i.getExtras();data.getString(“stringdata”);data.getInt(“intdata”); 3.传递值对象 （1）利用java自带的值对象序列化 java.io.Serializable 新建一个自定义类Human类，有两个成员变量 String类型的name和int类型的年龄 第一步：使自定义的Human类实现Serializable接口 Aaty： 123Intent i ＝ new Intent(Aaty.this,Baty.class);i.putExtra(“human”,new Human(“zhangsan”,20));startActivity(i); Baty： 123Intent i = getIntent();Human human = (Human) i.getSerializableExtra(“human”); //获取值对象user.getName(); //使用对象 特点：java自带的序列化，jvm全自动序列化，所以执行效率较低。但操作简便，代码少。 （2）android机制的值对象序列化 android.os.Parcelable Aaty： 第一步：同样新建自定义类Human，并且使该类实现Parcelable接口 第二步：实现重写两个方法 describeContents()和writeToParcel()，第一个方法不用动，用它默认的就行，主要重写第二个方法： 1234writeToParcel(Parcel dest,int flags)｛dest.writeString(getName());dest.writeInt(getAge());｝ 第三步：新建一个Creator 1234567891011public static final Creator\&lt;Human\&gt; = new Creator\&lt;Human\&gt;()&#123; \@Override public Human createFromParcle(Parcel source)&#123; return new Human(sourse.readString(),source.readInt());&#125;\@Override public Human[] newArray(int size)&#123; return new User[size]; &#125;&#125;; //注意这里有分号 第四步： 12Intent i ＝ new Intent(Aaty.this,Baty.class);i.putExtra(“human”,new Human(“zhangsan”,20)); Baty： 12Human human = i.getParcelableExtra(“human”); //获取值对象human.getName(); //使用值对象 4.获取activity返回参数 有时候我们启动一个activity并传过去数据之后需要后者的activity做数据分析并给出返回值返回前者activity activity2:点击按钮执行： 1234Intent i = new Intent();i.putExtra(“data”,editText.getText().toString());setResult(1,i);//1是传递数据的状态码(结果码)（可自定义，成功失败或失败的原因）。finish();//结束当前activity并将返回值传回原activity。 activity2: 123456startActivityForResult(i,0);//0是传递数据的请求码 \@Override protected void onActivityResult(int requestCode,int resultCode,Intent data)&#123; super.onActivityResult(requestCode, resultCode, data); String s = “activity2返回的数据为”＋data.getStringExtra(“data”);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比悲伤更悲伤的故事：我不能在你身边]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%9C%89%E4%B8%80%E7%A7%8D%E6%82%B2%E4%BC%A4%2F</url>
    <content type="text"><![CDATA[有一种悲伤 打 开 的 第 一 件 事 情 就 是 想起我 竭 尽 全 力 不 负 遇 见 ▼ 我的不定时更新｜ 与你说晚安 “人为什么要结婚啊？” “大概是当你老的时候，或是需要被照顾的时候，那个人可以理直气壮地一直陪在你身边。” 今晚上跟陈小朋友去电影院看了《比悲伤更悲伤的故事》，去之前就听说这部电影很催泪，以为自己不会再那么容易被俗套剧情打动，没想到看到最后，还是红了眼眶。 K和Cream从高中起相识，一个是父亲去世，被母亲抛弃；一个是双亲在车祸中去世，相似的经历，同样的孤独，让他们自然而然地走到了一起，同居十几年。 其实就算故事的剧情里没有铺垫，十几年的时间是谁都无法忽略不计的，那是各自人生阶段里最好也是最糟糕的青春。 更何况是这样身世彼此陪伴的两个人，他们早已经是对方世界里的不可或缺。 K知道自己身患绝症，时间不多，他最担心的是Cream。 希望用给她找一个好男人的方式，帮她安顿好他去世后的生活，可是他不知道的是，当Cream知道他身患绝症以后，她没有拆穿，也没有说破，只是默默的成全他的所有，包括希望自己去找个好男人嫁了。 不太记得是从哪一段开始哭的，但看到K从婚纱店跑出来，在天桥上，他以为对面站着的是穿着婚纱的Cream，结果不过是自己的一场幻觉而已，电影院里所有人也都在默默的擦眼泪。 他们都竭尽全力，把自己所能想到的最好的爱，给了对方。 比悲伤更悲伤的是，两个人明明相互惦念着，相互深爱着，却没有好好地在一起过。 看到K明明已经把“我爱你”三个字打进了对话框，最后还是一个字一个字的删掉了，换成了一句“你要幸福”发出去。Cream眼睛里含着泪水，回了一句“谢谢”。 其实，只要他勇敢地说出那句话，宋媛媛一定会义无反顾地和他在一起，无论他贫穷或富有，无论他健康或疾病，陪在他的身边，直到生命的最后一刻。 就像Cream所说的，我要的不是在寒冬中送我热咖啡的人，而是下雨天陪我一起吃冰的人。 我要的不是守护我的人，而是和我一起冒险的人，我要的不是别人，而是你。 K没有说出口，Cream也满足他的心愿，和别人走进了婚姻殿堂，看过电影的人都知道，其实Cream之前就发现K患病的事，也知道了他一直自己默默承受，还有为她所做的一切。 可是爱情这件事，是骗不了人的。Cream骗不了自己的心，她还是选择回到了K的身边。在K最孤独最需要拥抱的时候，给了他最深的拥抱，陪他走完生命的最后时光。 我想，如果在生命的最后一刻，没有看到最爱的人，那才是最遗憾的。 相比较电影里那些排除万难都为对方着想的爱情，再看看身边那些近在咫尺却无比计较，生怕自己多付出一分一毫的感情，等到失去的时候，除了遗憾和回忆，也再没什么其他了吧。 电影的结束，是爱情的再次相遇。现实里更多的，很多人都在爱情里错过或者迷惘。 我们总以为下次还有机会，直到有一天，离别摆在了眼前，才知道没有什么来日方长，想做的事情就马上做，想见的人就马上见，喜欢的人就好好珍惜，不要等到来不及，不要让自己有遗憾。 也许正是因为知道了限期，他们才会竭尽全力把自己最好的爱给对方。就像张敬轩那首《只是太爱你》唱的：“因为不知道下一辈子还是否能遇见你，所以我今生才会那么努力，把最好的给你。” 我们的人生只有一次，无法重来，重要的不是把人生过得多精彩，而是如何让人生的遗憾少一点，再少一点。 那什么才是人生的遗憾呢？人生的遗憾不是做错了什么，而是我本可以，但我却没这么做。 《比悲伤更悲伤的故事》里有一段说： 我不喜欢永远，因为少了一个人永远就不成立了，下辈子听起来还不错，像一个浪漫的约定。 下辈子的话，做个戒指、做个眼镜、做床棉被都好，只要能一直陪在你身旁就好。 慢慢的男女都会明白，无法跟喜欢的人在一起是人生的常态。 慢慢的大家都会明白爱不爱，可不可以在一起，能不能结婚是三件截然不同的事。 慢慢的我们都会体会到比悲伤更悲伤的事，不是他不爱你，而是明明两个人互相惦念、互相喜欢，却无法在这一辈子在一起，只能希望寄托在下辈子身上了。 所以我想，在那些在电影院里哭成泪人的女孩身上，应该都曾发生过一些爱而不得、无可奈何的故事吧！ 只是借着电影的由头，好好哭一场 1、如果爱必须要说出口，那哑巴如何相爱。 故事来源：\@雪泥鸿爪 第一年，我高一，他高二。 我在楼梯的拐角差点撞到他，他戴着白色耳机，不知道有没有听到我心慌意乱的对不起。 后来的周一升旗仪式上，他做国旗下讲话，讲完认认真真的鞠躬致谢。距离他几十米的我，心里涟漪再起。 第二年，我高二，他高三。 我们换了班主任，竟然是他的母亲。 最后一节课，我胃疼去办公室请假，正遇上他。班主任说，那你扶她去校门口吧。 我一直记着那几百米的距离，初春的天气，他扶着我的胳膊，蓝色的校服相互依偎。 第三年，我高三，他大一。 学校里没有他，连那偶尔的擦肩而过也没有了，我也不再在校园里四处游荡。 第四年，我大一，他大二。 我终于再一次和他站在同一片土地，他依旧优秀，在大学里风生水起。 那年冬天的第一场雪，下得很大，我踩着厚厚的积雪去图书馆还书。 在图书馆门口，我就这样看到了他。他还是高中的样子，站在那里，笔直挺拔。 他笑着接过一个女孩子手里的书，给她的一只手带上手套，另一只手放进他的大衣口袋里握住。 那天晚上，我把这几年写的日记本全都放进了一个小纸箱里。 喜欢了一个人五年，最终还是成了人海茫茫中的两个陌生人。 2、 说真话需要勇气，但为了爱的人， 将谎话说到底，需要更大的勇气。 故事来源：\@喵小七 我闺蜜很漂亮，公认的班花。 班里一个男生喜欢她，但是又不敢正面打交道，然后就让我帮他送情书、写信、送礼物、传悄悄话。 然后我帮他追我闺蜜追了三年，直到初中毕业都没成。 闺蜜当时也不是不喜欢那男生啊，只是太懵懂，觉得做朋友就好了。 七年以后我跟闺蜜聚在一起，提起当初的事情。我半开玩笑说，“哎，你干嘛不答应人家，人家真的挺好的，你不要给我多好。” 闺蜜：“你喜欢他？”，我：“嗯”。 闺蜜：“那你干嘛不说？” 我说：“可是我知道他一心喜欢你呀，他跟你在一起我才会觉得幸福。” 后来大概闺蜜偷偷跟那个男生讲了，那个男生特意要到我的联系方式，然后说了声：“谢谢你”。 3、 “如果还有来生，你想做什么。？” “除了做人，什么都行。戒指，眼镜，床，日记。” “下辈子做这些东西？有什么意思？” “你可以把我买回去，在你身边永远都有意思。” 故事来源：\@小机灵 临别之际，我大包小包的在食堂门口等他。 还记得他穿着的是牛仔裤，配白色T恤，他看着我说：“有什么事？” 我笑着说：“没什么事，就觉得马上要放假了，两个月见不着特意跟你告个别。” 他也笑了：“还特意告个别。” 我突然不知道哪里来的勇气，说了一句：“能抱下你吗？” 他犹豫地看着我：“抱……抱吧？” 我轻轻抱了一下，小心翼翼，生怕我们的感情就像瓷器，稍微用力，就出现裂缝。 那次，我还送了他一个红豆骰子链子，以表相思之情。 虽然，不知道他现在怎么处理了那个红豆链子，我是真的挺想成为那个红豆链子，哪怕只是待在他身边一小段时间。 电影的最后一幕，看见K和Cream的墓碑，我突然明白了：这就是之前铺垫的下辈子。 因为我不知道下一辈，还是否能遇见你，所以我今生才会和你一起离开。 但我们都知道，这世上根本没有下辈子。 所以一定要在这辈子去珍惜自己想爱的人，才不枉这一生。 谁叫这人生稍纵即逝。]]></content>
      <categories>
        <category>movie</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My secret]]></title>
    <url>%2F2019%2F03%2F25%2Fsecery%2F</url>
    <content type="text"><![CDATA[This is a my secret！！ I love 26519 25991 20961~]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello WorldToday I created my blog…..date:2019.03.24 My information: Name: Chenyuxiang Age: 22 Sex：man School:Minnan Normal University]]></content>
  </entry>
</search>
